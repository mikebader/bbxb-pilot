[["index.html", "Baltimore Block-by-Block Pilot Sample Selection 1 Overview", " Baltimore Block-by-Block Pilot Sample Selection Mike Bader Compiled: June 26, 2024 1 Overview Sampling plan for the pilot data acquisition of the Baltimore Block-by-Block project. The sample proceeded in two stages with a selection of neighborhood clusters in which to collect data based on maximizing variation in streetscapes and then selecting street segments to observe within those neighborhood clusters. "],["neighborhood-sample.html", "2 Neighborhood Sample 2.1 Data 2.2 Univariate Distributions 2.3 Bivariate/Trivariate Relationships 2.4 Map Distributions 2.5 Proposed Sample Neighborhoods", " 2 Neighborhood Sample 2.1 Data Data come from two sources. The first are variables downloaded from various city sources for the number of vacant buildings, the number of 311 requests for street repairs, and the median (?) date of housing construction. These variables are saved in the CSV file data/potholes-vacants-yearbuilt.csv. The last variable is the number of housing units. This variable comes from table B25001 in the American Community Survey. That data is obtained using the get_acs() function of the tidycensus library, which also downloads geography to be used for mapping values. I merge the two tables and then create a variable that calculates the ratio of vacant buildings to housing units in the tract (this is a rough adjustment for number of buildings). ## Data from City Sources dta &lt;- read_csv(&quot;data/potholes-vacants-yearbuilt.csv&quot;, col_types = &quot;cciii&quot;) %&gt;% mutate( ) %&gt;% rename(GEOID = tract) ## ACS Data (including geography) hu &lt;- get_acs( geography = &quot;tract&quot;, variables = &quot;B25001_001&quot;, state = &quot;MD&quot;, county = &quot;510&quot;, geometry = TRUE ) %&gt;% sf::st_transform(crs = sf::st_crs(&quot;EPSG:6487&quot;)) %&gt;% rename(hu = estimate) %&gt;% select(GEOID, hu) %&gt;% left_join(dta, by = &quot;GEOID&quot;) %&gt;% mutate( lnvacant = log(vacant + 1), vacrat = vacant / hu, lnvacrat = if_else(hu &gt; 0, log((vacant + 1) / hu), NA_real_) ) 2.2 Univariate Distributions Density the univariate distributions of the three variables we are examining for this analysis. ## Specify variables and labels varnms &lt;- c(&quot;vacrat&quot;, &quot;streetrepairs&quot;, &quot;yearblt&quot;) varlab &lt;- c(&quot;Vacant ratio&quot;, &quot;Street repair requests&quot;, &quot;Year built&quot;) names(varlab) &lt;- varnms ## Set unique limits and breaks for plots (also used in maps below) varlims &lt;- list( vacrat = c(0, 0.55), streetrepairs = c(0, 3100), yearblt = c(1890, 2010) ) varbrks &lt;- list( vacrat = seq(0, 0.55, 0.1), streetrepairs = seq(0, 3000, 1000), yearblt = seq(1890, 2010, 30) ) varlabs &lt;- list( vacrat = sprintf(&quot;%.1f&quot;, varbrks[[1]]), streetrepairs = as.character(varbrks[[2]]), yearblt = as.character(varbrks[[3]]) ) ## Function to create univariate density plot densplot &lt;- function(v) { ggplot(hu, aes(x = .data[[v]])) + geom_density() + scale_x_continuous( limits = varlims[[v]], breaks = varbrks[[v]] ) + labs(x = NULL, y = NULL) } ## Plot density plots into row d_plts &lt;- map(varnms, densplot) d_pltrow &lt;- ggarrange(d_plts[[1]], d_plts[[2]], d_plts[[3]], nrow = 1) ## Warning: Removed 2 rows containing non-finite outside the scale range ## (`stat_density()`). ## Warning: Removed 1 row containing non-finite outside the scale range (`stat_density()`). ## Removed 1 row containing non-finite outside the scale range (`stat_density()`). d_pltrow 2.3 Bivariate/Trivariate Relationships Calculate the correlations between the variables. hu %&gt;% as_tibble() %&gt;% select(lnvacrat, streetrepairs, yearblt) %&gt;% as.matrix() %&gt;% cor(use = &quot;pairwise&quot;) %&gt;% round(2) ## lnvacrat streetrepairs yearblt ## lnvacrat 1.00 -0.24 -0.34 ## streetrepairs -0.24 1.00 0.21 ## yearblt -0.34 0.21 1.00 Plot bivariate scatterplots of the three variables and a correlation matrix. sct1 &lt;- ggplot(hu, aes(x = streetrepairs, y = yearblt)) + geom_point(size = 0.75) + geom_smooth(method = &quot;lm&quot;, se = FALSE) sct2 &lt;- ggplot(hu, aes(x = streetrepairs, y = lnvacrat)) + geom_point(size = 0.75) + geom_smooth(method = &quot;lm&quot;, se = FALSE) sct3 &lt;- ggplot(hu, aes(x = yearblt, y = lnvacrat)) + geom_point(size = 0.75) + geom_smooth(method = &quot;lm&quot;, se = FALSE) ttl &lt;- ggplot() + labs(title = &quot;Bivariate relationships among variables&quot;) + theme(title = element_text(face = &quot;bold&quot;)) cor_plt &lt;- ggarrange( ggarrange(ttl), ggarrange(sct1, NULL, sct2, sct3), nrow = 2, heights = c(.1, .9) ) cor_plt ggsave(&#39;out/img/scatterplots.pdf&#39;, width = 7.25, height = 5.5, units = &quot;in&quot;) 2.4 Map Distributions Below, we plot values of the three variables onto maps of Baltimore. The white boundaries represent the Census public-use microdata areas (PUMAs). The figure below is saved to out/img/variable-maps-densities.pdf. ## Download PUMA geography pumas &lt;- pumas(state = &quot;24&quot;, year = 2022) %&gt;% filter(PUMACE20 %in% paste0(&quot;0080&quot;, 1:5)) ## Download and crop Chesapeake Bay geography f_chpk &lt;- &quot;data/Chesapeake_Bay_92_Segments/Chesapeake_Bay_92_Segments.shp&quot; dta_chpk &lt;- st_read(f_chpk) %&gt;% sf::st_transform(crs = sf::st_crs(&quot;EPSG:6487&quot;)) %&gt;% st_crop(st_bbox(hu)) ## Warning: attribute variables are assumed to be spatially constant throughout ## all geometries bmplot &lt;- function(v) { ggplot() + geom_sf(data = hu, aes(fill = .data[[v]])) + geom_sf(data = dta_chpk, fill = &quot;white&quot;, color = &quot;#dddddd&quot;, linewidth = .35) + geom_sf(data = pumas, alpha = 0, color = &quot;white&quot;, linewidth = .5) + scale_fill_viridis_c( limits = varlims[[v]], breaks = varbrks[[v]], labels = varlabs[[v]] )+ labs( title = varlab[v], fill = NULL ) + theme_map } bm_plts &lt;- map(varnms, bmplot) ttl &lt;- ggplot() + labs(title = &quot;Distributions of built environment variables&quot;) + theme(title = element_text(face = &quot;bold&quot;)) d_plts_c &lt;- map(d_plts, function(p) { p + theme( axis.text.y = element_blank() ) }) ggarrange( ttl, ggarrange(bm_plts[[1]], bm_plts[[2]], bm_plts[[3]], nrow = 1), ggarrange(d_plts_c[[1]], d_plts_c[[2]], d_plts_c[[3]], nrow = 1), nrow = 3, heights = c(.075, .45, .15) ) ## Warning: Removed 2 rows containing non-finite outside the scale range ## (`stat_density()`). ## Warning: Removed 1 row containing non-finite outside the scale range (`stat_density()`). ## Removed 1 row containing non-finite outside the scale range (`stat_density()`). ggsave(&quot;out/img/variable-maps-densities.pdf&quot;, width = 7.25, height = 5.5, units = &quot;in&quot;) 2.5 Proposed Sample Neighborhoods Based on variation across the three different variables above (and our knowledge of the racial/ethnic and socioeconomic distributions), we may consider sampling the following neighborhoods. The neighborhood names come from spatial data maintained by Baltimore City official list. proposed_nhds &lt;- list( # Central Baltimore central = c( &quot;Old Goucher&quot;, &quot;Barclay&quot;, &quot;East Baltimore Midway&quot;, &quot;Broadway East&quot;, &quot;Berea&quot; ), # Northwest northwest = c( &quot;Fallstaff&quot;, &quot;Cross Country&quot;, &quot;Glen&quot;, &quot;Cheswolde&quot; ), # North Central north_central = c( &quot;North Roland Park/Poplar Hill&quot;, &quot;The Orchards&quot;, &quot;Bellona-Gittings&quot;, &quot;Cedarcroft&quot;, &quot;Rosebank&quot;, &quot;Lake Evesham&quot;, &quot;Homeland&quot; ), # West west = c( &quot;Carrollton Ridge&quot;, &quot;Boyd-Booth&quot;, &quot;Penrose/Fayette Street Outreach&quot;, &quot;Evergreen Lawn&quot;, &quot;Bridgeview/Greenlawn&quot;, &quot;Rosemont Homeowners/Tenants&quot;, &quot;Midtown-Edmondson&quot; ), # South south = c( &quot;Cherry Hill&quot;, &quot;Brooklyn&quot; ), # East east = c( &quot;Highlandtown&quot;, &quot;Greektown&quot;, &quot;Canton&quot;, &quot;Brewers Hill&quot; ) ) The proposed neighborhoods are plotted in orange below. This covers variation across our three variables and some racial and socioeconomic variation. It does, however, miss much of East Baltimore (especially the Northeast). Mac and I ran an experiment a while back and covered the streets along the route at this link in one hour and fifteen minutes. Based on that, itâ€™s possible that we can do the cluster of neighborhoods in the Northwest and in the Roland Park/Homeland area in one day, the Midtown and Old Goucher/Broadway East stretch another day, South Baltimore a third day, and have another day to do more on the East Side. f_nhd &lt;- &quot;data/Neighborhood/Neighborhood.shp&quot; dta_nhd &lt;- st_read(f_nhd, quiet = TRUE) dta_bal &lt;- dta_nhd %&gt;% st_buffer(5) %&gt;% st_union() %&gt;% st_buffer(-5) dta_pnhd &lt;- dta_nhd %&gt;% filter(Name %in% unlist(proposed_nhds)) nrow(dta_pnhd) == length(proposed_nhds) # Check that all proposed neighborhoods # are in data # Add proposed neighborhood to map plots p_pnhd &lt;- geom_sf(data = dta_pnhd, alpha = 0, color = &quot;orange&quot;, linewidth = 0.65) p_build &lt;- geom_sf(data = filter(dta_nhd, Name %in% c(&quot;Greenmount West&quot;, &quot;Oliver&quot;)), fill = &quot;red&quot;) p_parity &lt;- geom_sf(data = filter(dta_nhd, Name %in% c(&quot;Harlem Park&quot;)), fill = &quot;lightblue&quot;) p_coppin &lt;- geom_sf(data = filter(dta_nhd, str_detect(Name, &quot;Coppin&quot;)), fill = &quot;pink&quot;) bm_pnhds &lt;- map(bm_plts, function(p) {return(p + p_pnhd + p_build + p_parity + p_coppin)}) ttl &lt;- ggplot() + labs(title = &quot;Proposed neighborhoods for Trimble sample&quot;) + theme(title = element_text(face = &quot;bold&quot;)) ggarrange( ttl, ggarrange(bm_pnhds[[1]], bm_pnhds[[2]], bm_pnhds[[3]], nrow = 1), nrow = 2, heights = c(.039, .236) ) ggsave( &quot;out/img/proposed-sample-locations.pdf&quot;, width = 7.25, height = 5.5, units = &quot;in&quot; ) Create a dataframe containing sampled areas that dissolves neighborhood boundaries. pnhdlabs &lt;- unlist(proposed_nhds) names(pnhdlabs) &lt;- str_replace(names(pnhdlabs), &quot;\\\\d+$&quot;, &quot;&quot;) dta_smpreg &lt;- dta_pnhd %&gt;% mutate( region = fct_recode(Name, !!!pnhdlabs) ) %&gt;% st_buffer(100) %&gt;% ## Avoid slivers by buffering by 500ft. group_by(region) %&gt;% summarize( ) %&gt;% st_zm() 2.5.1 Reference Maps The following maps provide a reference for the race/ethnicity and poverty composition of city neighborhoods. 2.5.2 Race/Ethnicity dta_re &lt;- get_acs( geography = &quot;tract&quot;, table = &quot;B03002&quot;, output = &quot;wide&quot;, state = &quot;MD&quot;, county = &quot;510&quot;, geometry = TRUE, cache_table = TRUE ) %&gt;% rename_with(~str_replace(., &quot;E$&quot;, &quot;&quot;))%&gt;% mutate( totpop = B03002_001, pnhw = B03002_003 / totpop, pnhb = B03002_004 / totpop, poth = (B03002_002 - (B03002_003 + B03002_004)) / totpop, phsp = B03002_012 / totpop ) %&gt;% sf::st_transform(crs = sf::st_crs(&quot;EPSG:6487&quot;)) plot_re &lt;- function(v, l) { ggplot() + geom_sf(data = dta_re, fill = &quot;#bbbbbb&quot;) + geom_sf(data = filter(dta_re, totpop &gt; 200), aes(fill = .data[[v]])) + geom_sf(data = dta_chpk, fill = &quot;white&quot;, color = &quot;#dddddd&quot;, linewidth = .35) + geom_sf(data = pumas, alpha = 0, color = &quot;white&quot;, linewidth = .5) + scale_fill_distiller( palette = &quot;Blues&quot;, direction = 1, limits = c(0, 1) ) + labs( title = paste(&quot;Percent&quot;, l) ) + theme_map } vars_re &lt;- c(Black = &quot;pnhb&quot;, White = &quot;pnhw&quot;, Latinx = &quot;phsp&quot;) plts_re &lt;- map2(vars_re, names(vars_re), plot_re) ggarrange( plts_re[[1]], plts_re[[2]], plts_re[[3]], nrow = 1 ) 2.5.3 Poverty dta_pov &lt;- get_acs( geography = &quot;tract&quot;, variables = c(&quot;B17001_001&quot;, &quot;B17001_002&quot;), output = &quot;wide&quot;, state = &quot;MD&quot;, county = &quot;510&quot;, geometry = TRUE, cache_table = TRUE ) %&gt;% mutate( totpop = B17001_001E, ppov = B17001_002E / totpop, ppovc = cut(ppov, seq(0, .4, .05)) ) ggplot() + geom_sf(data = dta_pov, fill = &quot;#bbbbbb&quot;) + geom_sf(data = filter(dta_pov, totpop &gt; 200), aes(fill = ppov)) + geom_sf(data = dta_chpk, fill = &quot;white&quot;, color = &quot;#dddddd&quot;, linewidth = .35) + geom_sf(data = pumas, alpha = 0, color = &quot;white&quot;, linewidth = .5) + scale_fill_distiller( palette = &quot;Blues&quot;, direction = 1, limits = c(0, .6), breaks = seq(0, 0.6, .1) ) + labs( title = &quot;Percent poor&quot;, fill = NULL ) + theme_minimal() + theme( title = element_text(face = &quot;bold&quot;), legend.position = &quot;top&quot;, panel.grid = element_blank(), axis.text = element_blank(), legend.key.width = unit(2, &quot;lines&quot;), legend.margin = margin(b = -3, unit = &quot;pt&quot;) ) # + # theme( # title = element_text(margin = margin(0, 0, 0, 0)), # legend.position = &quot;top&quot;, # legend.margin = margin(0, 0, 0, 0) # ) ## Use mapview to look have tooltip reveal census tract number # library(mapview) # mapview(hu, zcol = &quot;vacrat&quot;, label = &quot;GEOID&quot;) # mapview(pumas, linewidth = 20, color = &quot;white&quot;) + mapview(dta_nhd, label = &quot;Name&quot;, alpha = .5) # mapview(filter(dta_nhd, Name %in% c(&quot;Oliver&quot;, &quot;Greenmount West&quot;))) "],["sample-of-street-locations-for-routing.html", "3 Sample of Street Locations for Routing 3.1 Overview 3.2 Obtain Road Data 3.3 Select Primary/Secondary Roads in Sample Regions 3.4 Sample Streets within 1/4 Mile of Two Random Points on Major Streets 3.5 Combine and Save Sample Segments and Coordinates", " 3 Sample of Street Locations for Routing 3.1 Overview For each region comprised of the neighborhoods we selected, we will create sample street segments to observe. The plan will use the following steps: Select two roads classified as either primary or secondary on OpenStreetMap that are at least 1 mile long and survey the length of those streets (select points every 1/8th mile to put into route planning software) Select two points along each of those roads and select segments that intersect a 1/4 mile buffer of those This plan gives us the ability to measure change over distance on major streets, a sense of differences among cross-streets that intersect those major streets, and small streets that cluster only among small streets. 3.2 Obtain Road Data We download road data from OpenStreetMap and clip data to Baltimore (dataframe dta_osmrd). Set variable use_osm_cache to TRUE to use saved version of OSM data. If set to FALSE, or if the file does not exist, download the data and save it. library(osmdata) ## Data (c) OpenStreetMap contributors, ODbL 1.0. https://www.openstreetmap.org/copyright use_osm_cache &lt;- TRUE f_osmrd &lt;- &quot;data/osm-roads.shp&quot; strvals &lt;- c( &quot;motorway&quot;, &quot;primary&quot;, &quot;secondary&quot;, &quot;tertiary&quot;, &quot;residential&quot;, &quot;service&quot;, &quot;unclassified&quot; ) if(use_osm_cache == TRUE &amp; file.exists(f_osmrd)) { dta_osmrd &lt;- st_read(f_osmrd) } else { ## Get bounding box of neighborhood data bb &lt;- dta_nhd %&gt;% st_zm() %&gt;% st_transform(4326) %&gt;% st_bbox() ## Query OpenStreetMap data for streets q &lt;- opq(bbox = bb) %&gt;% add_osm_feature(key = &quot;highway&quot;, value = strvals) %&gt;% osmdata_sf() ## Project streets and clip to neighborhood boundaries dta_osmrd &lt;- q$osm_lines %&gt;% st_transform(st_crs(dta_nhd)) %&gt;% st_filter(dta_nhd, .predicate = st_intersects) %&gt;% select(osm_id, name, access, highway, lanes, maxspeed, oneway, surface) ## Save street network data st_write(dta_osmrd, f_osmrd, append = FALSE) } ## Reading layer `osm-roads&#39; from data source ## `/Users/mikebader/work/data-collection/bbxb-pilot/sample-design/data/osm-roads.shp&#39; ## using driver `ESRI Shapefile&#39; ## Simple feature collection with 33189 features and 8 fields ## Geometry type: LINESTRING ## Dimension: XY ## Bounding box: xmin: 1392530 ymin: 557978.2 xmax: 1449670 ymax: 624230.8 ## Projected CRS: NAD83 / Maryland (ftUS) dta_osmrd &lt;- dta_osmrd %&gt;% mutate( highway = factor(highway, levels = strvals) ) ## Plot street network ggplot(dta_osmrd) + geom_sf(aes(color = highway, linewidth = highway)) + scale_color_brewer(palette = &quot;Pastel1&quot;) + geom_sf(data = dta_smpreg, color = &quot;#ff6e30&quot;, alpha = 0, linewidth = 1) + theme_void() + scale_linewidth_manual(values = seq(1, 0.05, -0.95/8)) + labs( title = &quot;Map of streets by type&quot; ) We also create a set of streets clipped at the region boundaries so that the segments represent those completely within the regional boundaries. The data are saved in the object dta_rdreg. dta_rdreg &lt;- dta_osmrd %&gt;% st_intersection(dta_smpreg) ## Warning: attribute variables are assumed to be spatially constant throughout ## all geometries 3.3 Select Primary/Secondary Roads in Sample Regions We want to select two roads classified as either primary or secondary roads that is at least a mile long in each of the sampled regions. To identify these roads, we need to dissolve segments on the same road into a single segment. Since a road may change classifications between primary and secondary, we create an indicator of whether each segment is primary or secondary. Then dissolve the streets based on that indicator and the name of the street. These are saved in the dataframe object dta_rdmaj. We then spatially intersect the road with to clip the segments to the region polygon boundaries. We then calculate the length of the dissolved segment and keep those longer than one mile. We then randomly sort those to create a random sample of streets in each region. These data are saved in dta_rdmajsmp. set.seed(292126) dta_rdmajsmp &lt;- dta_rdreg %&gt;% mutate( majrd = highway %in% c(&quot;primary&quot;, &quot;secondary&quot;) ) %&gt;% filter(majrd) %&gt;% group_by(region, highway, name) %&gt;% summarize(.groups = &quot;keep&quot;) %&gt;% ungroup() %&gt;% mutate( rnd = runif(nrow(.)), majrdid = row_number(), len = as.numeric(st_length(geometry)), ) %&gt;% filter(len &gt; (5280 * .75)) %&gt;% group_by(region) %&gt;% arrange(rnd) %&gt;% mutate( row = row_number(), sampled = row_number() &lt; 4 ) %&gt;% ungroup() ggplot() + geom_sf(data = dta_rdreg, color = &quot;#eeeeee&quot;, linewidth = 0.25) + geom_sf(data = dta_smpreg, color = &quot;orange&quot;, linewidth = 1, alpha = 0) + geom_sf(data = dta_rdmajsmp, aes(color = sampled), linewidth = 0.75) mapview(dta_rdmajsmp, zcol = &quot;sampled&quot;, label = &quot;name&quot;) + mapview(dta_smpreg, col.regions = &quot;orange&quot;) For sampled streets, we want to generate a list of points along the length of the segment every 300ft to create points for route planning software. The dist_to_pct() function calculates percentages along the segment to be sampled (with a random start buffer) of each segment at a distance to be specified. This is for each portion of a segment (so points may be more densely sampled than 300ft). To avoid too much bunching, however, we remove segment pieces shorter than 150ft. Those segments and sample lengths are saved in the dataframe dta_rdselect. Next, we create the sample of locations at 300ft intervals along all segments and save into a dataframe called dta_rdmajpts. dist_to_pct &lt;- function(len, distance) { buf &lt;- runif(1L) * distance / len # Percentage distance of random start npt &lt;- len %/% distance # Maximum number of points on segment ## Sample point on line proportional to length if less than distance if(npt == 0) { if(runif(1L) &lt; len / distance) return(runif(1L)) return(NA_real_) } ## Otherwise, calculate percentage of segment length at which to create points pct &lt;- (c(0:(npt)) * distance) / len + buf ret &lt;- unlist(pct[pct &lt;= 1]) ret } # dta_rdmajsmp &lt;- dta_rdmajsmp %&gt;% # mutate( # len = as.numeric(st_length(geometry)), # pts = map(len, ~dist_to_pct(.x, 300)), # npts = unlist(map(pts, ~length(.x))) # ) dta_rdmajsmp &lt;- dta_rdmajsmp %&gt;% mutate( len = as.numeric(st_length(geometry)), pts = map(len, ~dist_to_pct(.x, 300)), npts = unlist(map(pts, ~length(.x))) ) dta_rdselect &lt;- dta_rdmajsmp %&gt;% filter(sampled) %&gt;% st_cast(&quot;LINESTRING&quot;) %&gt;% mutate( len = as.numeric(st_length(geometry)), pts = map(len, ~dist_to_pct(.x, 300)) ) %&gt;% filter(len &gt;= 150) ## Warning in st_cast.sf(., &quot;LINESTRING&quot;): repeating attributes for all ## sub-geometries for which they may not be constant rdselectpt &lt;- map2( dta_rdselect$geometry, dta_rdselect$pts, ~st_line_sample(.x, sample = unlist(.y)) ) %&gt;% map(~st_set_crs(.x, st_crs(dta_rdmajsmp))) %&gt;% reduce(c) dta_rdmajpts &lt;- dta_rdselect %&gt;% select(region, name, majrdid) %&gt;% st_drop_geometry() %&gt;% st_set_geometry(rdselectpt) %&gt;% st_cast(&quot;POINT&quot;) ## Warning in st_cast.sf(., &quot;POINT&quot;): repeating attributes for all sub-geometries ## for which they may not be constant ggplot(dta_rdmajpts) + geom_sf(size = 0.05) + geom_sf(data = dta_bal, aes(), alpha = 0, color = &quot;#aaaaaa&quot;) + theme_void() 3.4 Sample Streets within 1/4 Mile of Two Random Points on Major Streets Next, we sample two points along each of the sampled major roads. We then draw a 1/4 mile buffer around each of those points and obtain all minor streets within that buffer. We obtain the points at 5%, 50% and 95% of the length to input into the route-planning software. randpt &lt;- dta_rdmajpts %&gt;% group_by(majrdid) %&gt;% sample_n(2) randbuf &lt;- randpt %&gt;% st_buffer(5280/4) dta_rdxsmp &lt;- dta_osmrd %&gt;% st_filter(randbuf, join = st_intersects) rdxpts &lt;- map2( dta_rdxsmp$geometry, rep(list(c(0.05, .5, 0.95)), nrow(dta_rdxsmp)), ~st_line_sample(.x, sample = unlist(.y)) ) %&gt;% map(~st_set_crs(.x, st_crs(dta_rdxsmp))) %&gt;% reduce(c) dta_rdxpts &lt;- dta_rdxsmp %&gt;% st_drop_geometry() %&gt;% st_set_geometry(rdxpts) %&gt;% st_cast(&quot;POINT&quot;) ## Warning in st_cast.sf(., &quot;POINT&quot;): repeating attributes for all sub-geometries ## for which they may not be constant ggplot() + geom_sf(data = dta_smpreg, mapping = aes(), color = &quot;orange&quot;, linewidth = 1) + geom_sf(data = dta_rdmajpts, mapping = aes(), size = 0.05) + geom_sf(data = randpt, mapping = aes(), size = 0.1, color = &quot;red&quot;) + geom_sf(data = randbuf, mapping = aes(), color = &quot;red&quot;, alpha = 0) + geom_sf(data = dta_rdxpts, mapping = aes(), color = &quot;blue&quot;, size = 0.1) + geom_sf( data = dta_bal, mapping = aes(), color = &quot;#aaaaaa&quot;, linewidth = 0.5, alpha = 0 ) + theme_void() The map below provides a web interface to view the points sampled. mapview(dta_rdxpts, col.region = &quot;yellow&quot;) + mapview(randpt, col.regions = &quot;red&quot;) + mapview(dta_rdmajpts) + mapview(dta_rdxsmp) 3.5 Combine and Save Sample Segments and Coordinates Combine major streets and cross street samples into a single linestring spatial dataframe. Save this object, dta_sampled, to the file out/sample-segments.rdata. Export the coordinates for route planning along with their closest sample region to a comma separated values file, out/sample-coordinates.csv. dta_sampled &lt;- dta_rdmajsmp %&gt;% filter(sampled) %&gt;% bind_rows(dta_rdxsmp) save(dta_sampled, file = &quot;out/sample-segments.rdata&quot;) dta_coords &lt;- c(dta_rdxpts$geometry, dta_rdmajpts$geometry) %&gt;% st_sf() %&gt;% mutate( region = dta_smpreg$region[st_nearest_feature(., dta_smpreg)] ) %&gt;% st_transform(&quot;EPSG:4326&quot;) %&gt;% bind_cols(st_coordinates(.)) %&gt;% st_drop_geometry() write_csv(dta_coords, &quot;out/sample-coordinates.csv&quot;) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
